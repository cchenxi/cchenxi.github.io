<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on 陈曦的技术博客</title><link>https://cchenxi.github.io/tags/java/</link><description>Recent content in Java on 陈曦的技术博客</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 19 Nov 2021 19:00:36 +0800</lastBuildDate><atom:link href="https://cchenxi.github.io/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>在Java中写一个正确的单例模式</title><link>https://cchenxi.github.io/posts/%E5%9C%A8java%E4%B8%AD%E5%86%99%E4%B8%80%E4%B8%AA%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link><pubDate>Fri, 19 Nov 2021 19:00:36 +0800</pubDate><guid>https://cchenxi.github.io/posts/%E5%9C%A8java%E4%B8%AD%E5%86%99%E4%B8%80%E4%B8%AA%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid><description>本文参考极客时间每日一课《在Java中如何写一个正确的单例模式？》
1. 单例/单例设计模式 一个类只允许创建一个对象（实例），这个类就是一个单例类。这种设计模式叫做单例设计模式，简称单例模式。
实现一个单例类，需要关注：
构造函数私有，避免通过new关键字创建实例 创建时的线程安全问题 是否支持延迟加载 getInstance是否高性能（锁） 2. 单例模式的写法 2.1. 饿汉式 public class Singleton { private static final Singleton INSTANCE = new Singleton(); private Singleton() { } public static Singleton getInstance() { return INSTANCE; } } public class Singleton { private static Singleton instance; static { instance = new Singleton(); } private Singleton() {} public static Singleton getInstance() { return instance; } } 类加载时，静态实例就已经创建好并初始化好了。</description></item><item><title>GC日志解读</title><link>https://cchenxi.github.io/posts/gc%E6%97%A5%E5%BF%97%E8%A7%A3%E8%AF%BB/</link><pubDate>Sat, 05 Jun 2021 11:04:00 +0800</pubDate><guid>https://cchenxi.github.io/posts/gc%E6%97%A5%E5%BF%97%E8%A7%A3%E8%AF%BB/</guid><description>为深入学习GC（Garbage Collection，垃圾回收），本文将使用一段测试代码来测试不同的GC策略下的执行情况，并对输出的GC日志做简要分析。
1. 测试环境 1.1. 操作系统及jdk版本 ➜ 01jvm git:(main) ✗ java -version java version &amp;#34;1.8.0_131&amp;#34; Java(TM) SE Runtime Environment (build 1.8.0_131-b11) Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode) 1.2. 测试代码 测试代码来源： https://github.com/JavaCourse00/JavaCourseCodes/blob/main/01jvm/GCLogAnalysis.java
import java.util.Random; import java.util.concurrent.TimeUnit; import java.util.concurrent.atomic.LongAdder; /* 演示GC日志生成与解读 */ public class GCLogAnalysis { private static Random random = new Random(); public static void main(String[] args) { // 当前毫秒时间戳 long startMillis = System.currentTimeMillis(); // 持续运行毫秒数; 可根据需要进行修改 long timeoutMillis = TimeUnit.</description></item></channel></rss>